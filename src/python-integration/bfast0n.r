library(lubridate)
library(bfast)
library(strucchange)

# Module only containing the bfast0n function

EnableFastBfast = function()
{
    if (exists("set_fast_options"))
    {
        print("Using fast BFAST")
        set_fast_options()
        # Disable bfastts modifications due to issue #2
        options(bfast.use_bfastts_modifications=FALSE)
    } else print("Using reference BFAST, install appelmar/bfast for a speed increase")
}

BFAST0NBreaks = function(pixel, DateStart=2009, DateFrequency=23, DateOffset=8, Order=1,
                         t0 = as.Date("2014-01-01"), NoBreakValue = -9999, breaks="LWZ",
                         formula = response~trend+season, seasonfreq = 0.3, scsig=0.01)
{
    # Utility functions: here so that the scope is correct for SparkR
    GetBreakNumberWhole = function(bfts)
    {
        return(round(frequency(bfts)))
    }
    
    GetBreakNumber = function(dates)
    {
        1/((as.numeric(difftime(max(dates), min(dates), units="weeks")))/52.18)
    }
    
    BreakpointToDateSinceT0 = function(breakpoint_index, bpp, t0, offset=0)
    {
        result = as.integer(as.Date(date_decimal(BreakpointDate(breakpoint_index, bpp))) - t0) + offset
        if (is.numeric(result) && !is.na(result) && !is.nan(result) &&
            (result < as.integer(min(dates) - t0) || result > as.integer(max(dates) - t0)))
        {
            cat("Warning: breakpoint date out of valid range!\n") # -1900 to 1376
            cat(c("Note: breakpoint index: ", breakpoint_index ,"\n"))
            cat(c("Note: calculated days since t0: ", result ,"\n"))
            cat(c("Note: breakpoint date: ", BreakpointDate(breakpoint_index, bpp) ,"\n"))
        }
        return(result)
    }
    
    # DOY of breakpoint; NOTE: problems if the year doesn't match!
    BreakpointToDOY = function(breakpoint_index, bpp)
    {
        result = yday(date_decimal(BreakpointDate(breakpoint_index, bpp)))
        return(result)
    }
    
    # The date of the breakpoint in decimal years
    BreakpointDate = function(breakpoint_index, bpp)
    {
        if (!is.numeric(breakpoint_index) || is.nan(breakpoint_index) || is.na(breakpoint_index) ||
            length(breakpoint_index) > 1 || breakpoint_index <= 0 || breakpoint_index > nrow(bpp))
        {
            cat("Warning: asked to calculate date for an invalid breakpoint index!\n")
            cat(c("Note: The index was:", breakpoint_index, "\n"))
            return(NA)
        }
        return(bpp$time[breakpoint_index])
    }
    
    # Utility: In case we can't calculate anything, return NA values for all years.
    ReturnNAs = function()
    {
        rep(NA, length(Years)*3)
    }
    # Same but if there is no break
    ReturnNoBreak = function()
    {
        rep(NoBreakValue, length(Years)*3)
    }
    
    #bfts = bfastts(pixel, dates, type=TSType)
    bfts = ts(pixel, start=DateStart, frequency = DateFrequency)
    
    # Handling dates
    dates = as.Date(date_decimal(as.numeric(time(bfts))))
    DateRange = range(dates)
    Years = lubridate::year(DateRange[1]):lubridate::year(DateRange[2])
    
    # Check whether we have enough non-NA pixels for running breakpoints.full, without doing preprocessing.
    # The right hand side formula calculates the columns in the bfastpp object.
    #if (floor(sum(!is.na(pixel)) * GetBreakNumber(dates)) <= 4+(Order-1)*2 )
    #    return(rep(NA, length(Years)*3)) # Too many NAs
    
    # Return NA is we have all NA pixels
    if (all(is.na(pixel)))
        return(ReturnNAs())
    
    # Do not process pixels that have too low VI values (most likely bare soil/desert)
    # WARNING: need to check whether the threshold makes sense for non-EVI
    #if (mean(pixel, na.rm=TRUE) < 500)
    #    return(ReturnNoBreak())
    
    # Use integers
    if (GetBreakNumberWhole(bfts) <= 4+(Order-1)*2 || GetBreakNumberWhole(bfts) >= floor(sum(!is.na(pixel))/2))
        return(ReturnNAs()) # Too many NAs
    
    bpp = bfastpp(bfts, order=Order)
    
    # Add support for different bins for seasonal dummies
    myseason = as.numeric(as.character(bpp$season)) # Deparse season again
    if (!all(is.na(myseason))) # If we failed to deparse, then we're using a fixed bfastpp already, no need to do anything
        bpp$season = cut(myseason, frequency(bfts)*seasonfreq, ordered_result = TRUE) # Rebin all
    
    if (is.finite(scsig))
    {
        testforabreak = sctest(efp(formula, data=bpp, h=GetBreakNumber(dates), type="OLS-MOSUM"))
        if (is.null(testforabreak) || is.null(testforabreak$p.value) || !is.finite(testforabreak$p.value)) {
            cat("Warning: sctest did not return a valid value!\n")
            print(str(testforabreak))
            print(testforabreak)
        } else if (testforabreak$p.value > scsig) # If test says there should be no breaks
            return(ReturnNoBreak())
    }
    
    bf = tryCatch(breakpoints(formula, data=bpp, h=GetBreakNumberWhole(bfts), breaks=breaks),
                  error = function(e){print(e); traceback(e); cat(c("Note: pixel values were: ", pixel, "\n")); return(NULL)})
    
    if (is.null(bf))
    {
        cat("Warning: failed to run breakpoints, returning NA!\n")
        return(ReturnNAs())
    }
    
    # Direct returns without calling functions
    if (all(is.na(breakpoints(bf, breaks=breaks)$breakpoints)))
        return(ReturnNoBreak())
    
    # Make a matrix for the output
    OutMatrix = matrix(NoBreakValue, nrow=length(Years), ncol=3, dimnames=list(Years, c("confint.neg", "breakpoint", "confint.pos")))
    # Get confidence interval
    ConfInts = tryCatch(confint(bf, breaks=breaks)$confint,
                        error = function(e){print(e); traceback(e); cat(c("Note: pixel values were: ", pixel, "\n")); return(NA)})
    BreakpointYears = as.integer(sapply(breakpoints(bf, breaks=breaks)$breakpoints, BreakpointDate, bpp)) # Get years at which breakpoints happened
    if (any(duplicated(BreakpointYears))) # Sanity check: should never be true
        cat(c("ERROR: Duplicate breakpoint years! Years:", BreakpointYears, "Dates:", sapply(breakpoints(bf, breaks=breaks)$breakpoints, BreakpointDate, bpp), "Breakpoints:", breakpoints(bf, breaks=breaks)$breakpoints, "\n"))
    BreakpointDays = sapply(ConfInts, BreakpointToDateSinceT0, bpp, t0, DateOffset) # Convert indices to days since t0
    OutMatrix[as.character(BreakpointYears),] = BreakpointDays # Put it into our matrix in the right years
    return(c(t(OutMatrix))) # Flatten matrix
}
